/* automatically generated by rust-bindgen */

pub const _GLOB_H: ::std::os::raw::c_uint = 1;
pub const _SYS_CDEFS_H: ::std::os::raw::c_uint = 1;
pub const _FEATURES_H: ::std::os::raw::c_uint = 1;
pub const _DEFAULT_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC11: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC99: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC95: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX_IMPLICITLY: ::std::os::raw::c_uint = 1;
pub const _POSIX_SOURCE: ::std::os::raw::c_uint = 1;
pub const _POSIX_C_SOURCE: ::std::os::raw::c_uint = 200809;
pub const __USE_POSIX: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX2: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199309: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199506: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K8: ::std::os::raw::c_uint = 1;
pub const _ATFILE_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_MISC: ::std::os::raw::c_uint = 1;
pub const __USE_ATFILE: ::std::os::raw::c_uint = 1;
pub const __USE_FORTIFY_LEVEL: ::std::os::raw::c_uint = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: ::std::os::raw::c_uint = 0;
pub const _STDC_PREDEF_H: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559__: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559_COMPLEX__: ::std::os::raw::c_uint = 1;
pub const __STDC_ISO_10646__: ::std::os::raw::c_uint = 201706;
pub const __STDC_NO_THREADS__: ::std::os::raw::c_uint = 1;
pub const __GNU_LIBRARY__: ::std::os::raw::c_uint = 6;
pub const __GLIBC__: ::std::os::raw::c_uint = 2;
pub const __GLIBC_MINOR__: ::std::os::raw::c_uint = 26;
pub const __glibc_c99_flexarr_available: ::std::os::raw::c_uint = 1;
pub const __WORDSIZE: ::std::os::raw::c_uint = 64;
pub const __WORDSIZE_TIME64_COMPAT32: ::std::os::raw::c_uint = 1;
pub const __SYSCALL_WORDSIZE: ::std::os::raw::c_uint = 64;
pub const __HAVE_GENERIC_SELECTION: ::std::os::raw::c_uint = 1;
pub const GLOB_ERR: ::std::os::raw::c_uint = 1;
pub const GLOB_MARK: ::std::os::raw::c_uint = 2;
pub const GLOB_NOSORT: ::std::os::raw::c_uint = 4;
pub const GLOB_DOOFFS: ::std::os::raw::c_uint = 8;
pub const GLOB_NOCHECK: ::std::os::raw::c_uint = 16;
pub const GLOB_APPEND: ::std::os::raw::c_uint = 32;
pub const GLOB_NOESCAPE: ::std::os::raw::c_uint = 64;
pub const GLOB_PERIOD: ::std::os::raw::c_uint = 128;
pub const GLOB_MAGCHAR: ::std::os::raw::c_uint = 256;
pub const GLOB_ALTDIRFUNC: ::std::os::raw::c_uint = 512;
pub const GLOB_BRACE: ::std::os::raw::c_uint = 1024;
pub const GLOB_NOMAGIC: ::std::os::raw::c_uint = 2048;
pub const GLOB_TILDE: ::std::os::raw::c_uint = 4096;
pub const GLOB_ONLYDIR: ::std::os::raw::c_uint = 8192;
pub const GLOB_TILDE_CHECK: ::std::os::raw::c_uint = 16384;
pub const __GLOB_FLAGS: ::std::os::raw::c_uint = 32511;
pub const GLOB_NOSPACE: ::std::os::raw::c_uint = 1;
pub const GLOB_ABORTED: ::std::os::raw::c_uint = 2;
pub const GLOB_NOMATCH: ::std::os::raw::c_uint = 3;
pub const GLOB_NOSYS: ::std::os::raw::c_uint = 4;
pub type __size_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct glob_t {
    pub gl_pathc: __size_t,
    pub gl_pathv: *mut *mut ::std::os::raw::c_char,
    pub gl_offs: __size_t,
    pub gl_flags: ::std::os::raw::c_int,
    pub gl_closedir: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                    *mut ::std::os::raw::c_void)>,
    pub gl_readdir: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                   *mut ::std::os::raw::c_void)
                                              -> *mut ::std::os::raw::c_void>,
    pub gl_opendir: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                   *const ::std::os::raw::c_char)
                                              -> *mut ::std::os::raw::c_void>,
    pub gl_lstat: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                 *const ::std::os::raw::c_char,
                                                             arg2:
                                                                 *mut ::std::os::raw::c_void)
                                            -> ::std::os::raw::c_int>,
    pub gl_stat: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                *const ::std::os::raw::c_char,
                                                            arg2:
                                                                *mut ::std::os::raw::c_void)
                                           -> ::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout_glob_t() {
    assert_eq!(::std::mem::size_of::<glob_t>() , 72usize , concat ! (
               "Size of: " , stringify ! ( glob_t ) ));
    assert_eq! (::std::mem::align_of::<glob_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( glob_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const glob_t ) ) . gl_pathc as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( glob_t ) , "::" ,
                stringify ! ( gl_pathc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const glob_t ) ) . gl_pathv as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( glob_t ) , "::" ,
                stringify ! ( gl_pathv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const glob_t ) ) . gl_offs as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( glob_t ) , "::" ,
                stringify ! ( gl_offs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const glob_t ) ) . gl_flags as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( glob_t ) , "::" ,
                stringify ! ( gl_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const glob_t ) ) . gl_closedir as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( glob_t ) , "::" ,
                stringify ! ( gl_closedir ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const glob_t ) ) . gl_readdir as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( glob_t ) , "::" ,
                stringify ! ( gl_readdir ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const glob_t ) ) . gl_opendir as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( glob_t ) , "::" ,
                stringify ! ( gl_opendir ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const glob_t ) ) . gl_lstat as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( glob_t ) , "::" ,
                stringify ! ( gl_lstat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const glob_t ) ) . gl_stat as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( glob_t ) , "::" ,
                stringify ! ( gl_stat ) ));
}
impl Clone for glob_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn glob(__pattern: *const ::std::os::raw::c_char,
                __flags: ::std::os::raw::c_int,
                __errfunc:
                    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                   *const ::std::os::raw::c_char,
                                                               arg2:
                                                                   ::std::os::raw::c_int)
                                              -> ::std::os::raw::c_int>,
                __pglob: *mut glob_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn globfree(__pglob: *mut glob_t);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ql_error_t {
    SUCCESS = 0,
    ERROR = 1,
    FATAL = 2,
    MEMORY_ALLOCATION_FAILED = 3,
    NOT_INITIALISED = 4,
    ALREADY_INITIALISED = 5,
    INVALID_PARAMETERS = 6,
    INVALID_PAYLOAD = 7,
    INVALID_DATA = 8,
    INVALID_DATABASE = 9,
    INVALID_STORE = 10,
    INVALID_PATH = 11,
    INSERTION_FAILED = 12,
    REMOVAL_FAILED = 13,
    PUBKEY_EXISTS = 14,
    PUBKEY_NOT_FOUND = 15,
    NODE_NOT_FOUND = 16,
    USER_ALREADY_EXISTS = 17,
    USER_DOES_NOT_EXIST = 18,
    INVALID_PASSPHRASE = 19,
    ALREADY_AUTHENTICATED = 20,
    INVALID_AUTHENTICATION = 21,
    NOT_AUTHENTICATED = 22,
    FILE_ALREADY_EXISTS = 23,
    FILE_DOES_NOT_EXIST = 24,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum qaul_query_limit {
    STARTS_WITH = 0,
    ENDS_WITH = 1,
    EQUALS = 2,
    NEWER = 3,
    OLDER = 4,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct qaul_query {
    pub name: *mut *mut ::std::os::raw::c_char,
    pub name_limits: *mut qaul_query_limit,
    pub names: ::std::os::raw::c_short,
    pub time: *mut ::std::os::raw::c_uint,
    pub time_limits: *mut qaul_query_limit,
    pub times: ::std::os::raw::c_short,
    pub max_count: usize,
}
#[test]
fn bindgen_test_layout_qaul_query() {
    assert_eq!(::std::mem::size_of::<qaul_query>() , 56usize , concat ! (
               "Size of: " , stringify ! ( qaul_query ) ));
    assert_eq! (::std::mem::align_of::<qaul_query>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( qaul_query ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const qaul_query ) ) . name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( qaul_query ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const qaul_query ) ) . name_limits as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( qaul_query ) , "::" ,
                stringify ! ( name_limits ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const qaul_query ) ) . names as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( qaul_query ) , "::" ,
                stringify ! ( names ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const qaul_query ) ) . time as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( qaul_query ) , "::" ,
                stringify ! ( time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const qaul_query ) ) . time_limits as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( qaul_query ) , "::" ,
                stringify ! ( time_limits ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const qaul_query ) ) . times as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( qaul_query ) , "::" ,
                stringify ! ( times ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const qaul_query ) ) . max_count as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( qaul_query ) , "::" ,
                stringify ! ( max_count ) ));
}
impl Clone for qaul_query {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn ql_query_create(init: *mut qaul_query) -> ql_error_t;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct qaul_auth_token {
}
#[test]
fn bindgen_test_layout_qaul_auth_token() {
    assert_eq!(::std::mem::size_of::<qaul_auth_token>() , 0usize , concat ! (
               "Size of: " , stringify ! ( qaul_auth_token ) ));
    assert_eq! (::std::mem::align_of::<qaul_auth_token>() , 1usize , concat !
                ( "Alignment of " , stringify ! ( qaul_auth_token ) ));
}
impl Clone for qaul_auth_token {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct qaul_configuration {
}
#[test]
fn bindgen_test_layout_qaul_configuration() {
    assert_eq!(::std::mem::size_of::<qaul_configuration>() , 0usize , concat !
               ( "Size of: " , stringify ! ( qaul_configuration ) ));
    assert_eq! (::std::mem::align_of::<qaul_configuration>() , 1usize , concat
                ! ( "Alignment of " , stringify ! ( qaul_configuration ) ));
}
impl Clone for qaul_configuration {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct qaul_network {
}
#[test]
fn bindgen_test_layout_qaul_network() {
    assert_eq!(::std::mem::size_of::<qaul_network>() , 0usize , concat ! (
               "Size of: " , stringify ! ( qaul_network ) ));
    assert_eq! (::std::mem::align_of::<qaul_network>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( qaul_network ) ));
}
impl Clone for qaul_network {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct qaul_user_list {
}
#[test]
fn bindgen_test_layout_qaul_user_list() {
    assert_eq!(::std::mem::size_of::<qaul_user_list>() , 0usize , concat ! (
               "Size of: " , stringify ! ( qaul_user_list ) ));
    assert_eq! (::std::mem::align_of::<qaul_user_list>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( qaul_user_list ) ));
}
impl Clone for qaul_user_list {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct qaul_msg_list {
}
#[test]
fn bindgen_test_layout_qaul_msg_list() {
    assert_eq!(::std::mem::size_of::<qaul_msg_list>() , 0usize , concat ! (
               "Size of: " , stringify ! ( qaul_msg_list ) ));
    assert_eq! (::std::mem::align_of::<qaul_msg_list>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( qaul_msg_list ) ));
}
impl Clone for qaul_msg_list {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct qaul_file_list {
}
#[test]
fn bindgen_test_layout_qaul_file_list() {
    assert_eq!(::std::mem::size_of::<qaul_file_list>() , 0usize , concat ! (
               "Size of: " , stringify ! ( qaul_file_list ) ));
    assert_eq! (::std::mem::align_of::<qaul_file_list>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( qaul_file_list ) ));
}
impl Clone for qaul_file_list {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct qaul_user {
}
#[test]
fn bindgen_test_layout_qaul_user() {
    assert_eq!(::std::mem::size_of::<qaul_user>() , 0usize , concat ! (
               "Size of: " , stringify ! ( qaul_user ) ));
    assert_eq! (::std::mem::align_of::<qaul_user>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( qaul_user ) ));
}
impl Clone for qaul_user {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct qaul_message {
}
#[test]
fn bindgen_test_layout_qaul_message() {
    assert_eq!(::std::mem::size_of::<qaul_message>() , 0usize , concat ! (
               "Size of: " , stringify ! ( qaul_message ) ));
    assert_eq! (::std::mem::align_of::<qaul_message>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( qaul_message ) ));
}
impl Clone for qaul_message {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct qaul_file {
}
#[test]
fn bindgen_test_layout_qaul_file() {
    assert_eq!(::std::mem::size_of::<qaul_file>() , 0usize , concat ! (
               "Size of: " , stringify ! ( qaul_file ) ));
    assert_eq! (::std::mem::align_of::<qaul_file>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( qaul_file ) ));
}
impl Clone for qaul_file {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/**
 * Defines what type of OS is used for qaul,net
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum qaul_os { LINUX = 0, MACOS = 1, WINDOWS = 2, }
/**
 *
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct qaul {
    pub inner: *mut ::std::os::raw::c_void,
    pub os: qaul_os,
    pub home_path: *const ::std::os::raw::c_char,
    pub resource_path: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_qaul() {
    assert_eq!(::std::mem::size_of::<qaul>() , 32usize , concat ! (
               "Size of: " , stringify ! ( qaul ) ));
    assert_eq! (::std::mem::align_of::<qaul>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( qaul ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const qaul ) ) . inner as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( qaul ) , "::" ,
                stringify ! ( inner ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const qaul ) ) . os as * const _ as usize } ,
                8usize , concat ! (
                "Alignment of field: " , stringify ! ( qaul ) , "::" ,
                stringify ! ( os ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const qaul ) ) . home_path as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( qaul ) , "::" ,
                stringify ! ( home_path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const qaul ) ) . resource_path as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( qaul ) , "::" ,
                stringify ! ( resource_path ) ));
}
impl Clone for qaul {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /**
 * Initialise the qaul library for a specific operating system, a home path and resource path.
 *
 * The resource path can be used either for a native front-end or the
 * webserver web source which then serves the html files
 *
 * @param state
 * @param os
 * @param home
 * @param resources
 * @return
 */
    pub fn ql_initialise(state: *mut *mut qaul, os: qaul_os,
                         home: *const ::std::os::raw::c_char,
                         resources: *const ::std::os::raw::c_char)
     -> ql_error_t;
}
extern "C" {
    /**
 *
 * @param state
 * @return
 */
    pub fn ql_shutdown(state: *mut qaul) -> ql_error_t;
}
extern "C" {
    /**
 *
 * @param state
 * @param username
 * @param passphrase
 * @return
 */
    pub fn ql_create_user(state: *mut qaul,
                          username: *const ::std::os::raw::c_char,
                          passphrase: *const ::std::os::raw::c_char)
     -> ql_error_t;
}
extern "C" {
    /**
 *
 * @param state
 * @param username
 * @return
 */
    pub fn ql_delete_user(state: *mut qaul,
                          username: *const ::std::os::raw::c_char)
     -> ql_error_t;
}
extern "C" {
    /**
 *
 * @param state
 * @param username
 * @param passphrase
 * @param token
 * @return
 */
    pub fn ql_login(state: *mut qaul, username: *const ::std::os::raw::c_char,
                    passphrase: *const ::std::os::raw::c_char,
                    token: *mut *mut qaul_auth_token) -> ql_error_t;
}
extern "C" {
    /**
 *
 * @param state
 * @param token
 * @return
 */
    pub fn ql_logout(state: *mut qaul, token: *mut qaul_auth_token)
     -> ql_error_t;
}
extern "C" {
    /**
 * Get libary configuration
 *
 * @param state
 * @param config
 * @return
 */
    pub fn ql_get_configuration(state: *mut qaul,
                                config: *mut qaul_configuration)
     -> ql_error_t;
}
extern "C" {
    /**
 * Set library configuration
 *
 * @param state
 * @param config
 * @return
 */
    pub fn ql_set_configuration(state: *mut qaul, config: qaul_configuration)
     -> ql_error_t;
}
extern "C" {
    /**
 *
 * @param state
 * @param token
 * @param query
 * @param length
 * @param list
 * @return
 */
    pub fn ql_get_users(state: *mut qaul, token: *mut qaul_auth_token,
                        query: *mut qaul_query, length: *mut usize,
                        list: *mut qaul_user_list) -> ql_error_t;
}
extern "C" {
    /**
 *
 * @param state
 * @param token
 * @param key
 * @param value
 * @return
 */
    pub fn ql_get_user_data(state: *mut qaul, token: *mut qaul_auth_token,
                            key: *const ::std::os::raw::c_char,
                            value: *mut *mut ::std::os::raw::c_void)
     -> ql_error_t;
}
extern "C" {
    /**
 *
 * @param state
 * @param token
 * @param key
 * @param value
 * @return
 */
    pub fn ql_set_user_data(state: *mut qaul, token: *mut qaul_auth_token,
                            key: *const ::std::os::raw::c_char,
                            value: *mut ::std::os::raw::c_void) -> ql_error_t;
}
extern "C" {
    /**
 *
 * @param state
 * @param token
 * @param recipient
 * @param message
 * @return
 */
    pub fn ql_send_message(state: *mut qaul, token: *mut qaul_auth_token,
                           recipient: *const ::std::os::raw::c_char,
                           message: *const ::std::os::raw::c_char)
     -> ql_error_t;
}
extern "C" {
    /**
 *
 * @param state
 * @param token
 * @param name
 * @param data
 * @return
 */
    pub fn ql_get_file_meta(state: *mut qaul, token: *mut qaul_auth_token,
                            name: *const ::std::os::raw::c_char,
                            data: *mut *mut ::std::os::raw::c_void)
     -> ql_error_t;
}
extern "C" {
    /**
 *
 * @param state
 * @param token
 * @param id
 * @param file
 * @return
 */
    pub fn ql_add_file(state: *mut qaul, token: *mut qaul_auth_token,
                       id: *const ::std::os::raw::c_char, file: qaul_file)
     -> ql_error_t;
}
extern "C" {
    /**
 *
 * @param state
 * @param token
 * @param id
 * @return
 */
    pub fn ql_delete_file(state: *mut qaul, token: *mut qaul_auth_token,
                          id: *const ::std::os::raw::c_char) -> ql_error_t;
}
extern "C" {
    /**
 *
 * @param state
 * @param token
 * @param id
 * @return
 */
    pub fn ql_download_file(state: *mut qaul, token: *mut qaul_auth_token,
                            id: *const ::std::os::raw::c_char) -> ql_error_t;
}
extern "C" {
    /**
 *
 * @param state
 * @param username
 * @return
 */
    pub fn ql_init_call(state: *mut qaul,
                        username: *const ::std::os::raw::c_char)
     -> ql_error_t;
}
extern "C" {
    /**
 *
 * @param state
 * @param username
 * @return
 */
    pub fn ql_end_call(state: *mut qaul,
                       username: *const ::std::os::raw::c_char) -> ql_error_t;
}
extern "C" {
    /**
 *
 * @param state
 * @return
 */
    pub fn ql_accept_call(state: *mut qaul) -> ql_error_t;
}
extern "C" {
    /**
 *
 * @param state
 * @return
 */
    pub fn ql_reject_call(state: *mut qaul) -> ql_error_t;
}
extern "C" {
    /**
 *
 * @param state
 * @param network
 * @return
 */
    pub fn ql_get_network(state: *mut qaul, network: *mut qaul_network)
     -> ql_error_t;
}
extern "C" {
    /**
 *
 * @param state
 * @param network
 * @return
 */
    pub fn ql_configure_network(state: *mut qaul, network: qaul_network)
     -> ql_error_t;
}
extern "C" {
    /**
 *
 * @param state
 * @return
 */
    pub fn ql_get_binaries(state: *mut qaul) -> ql_error_t;
}
